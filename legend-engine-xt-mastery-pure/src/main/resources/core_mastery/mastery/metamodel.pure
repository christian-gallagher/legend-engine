// Copyright 2022 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

Class {doc.doc = 'Defines a Master Record and all configuration required for managing it in a mastering platform.'} meta::pure::mastery::metamodel::MasterRecordDefinition extends PackageableElement
{
  //{doc.doc = 'The name used to identify this master record that is unique within the parent Dataspace|Datastore.'} uniqueName : String[1];
  {doc.doc = 'The class that is managed in this Master Record. (For Alloy Mastery this must extend MasterRecord.)'} modelClass : meta::pure::metamodel::type::Class<Any>[1];
  {doc.doc = 'The identity resolution configuration used to identify a record in the master store using the inputs provided, the inputs usually do not contain the primary key'} identityResolution : meta::pure::mastery::metamodel::resolution::IdentityResolution[0..1];
  {doc.doc = 'Defines how child collections should conpare objects for equality, required only if the object type in a collection does not have an equality key stereotype defined.'} collectionEquality: meta::pure::mastery::metamodel::CollectionEquality[0..*];
  sources: meta::pure::mastery::metamodel::RecordSource[0..*];
}

Enum {doc.doc = 'A control used to define how to validate the queries generated and how to validate the the results of executing the queries.'}
meta::pure::mastery::metamodel::resolution::ResolutionKeyType
{

{doc.doc = 'Validated against equality key to ensure an actual PK and fail if the field is provided and a match is not found.'} GeneratedPrimaryKey,
{doc.doc = 'Validated against equality key to ensure an actual PK and create a new record if a match is not found.'} SuppliedPrimaryKey,
{doc.doc = 'If an AlternateKey is specified then at least one required in the input record or fail resolution, if (ChangeProposal.CurationModel == Create) then the input source is attempting to create a new record (e.g. from UI) block if existing record found.'} AlternateKey, 
{doc.doc = 'Used for matching if supplied but no validation is applied.'} Optional
  // Original 
  // {doc.doc = 'Optional field but if present in the input data it must produce a single match, effectively a primary key.'} MandatoryOnResultIfProvided,
  // {doc.doc = 'A required field on the input but if matched it indicates that a duplicate is about to be created, typically used in record creation use cases from a UI.'} MandatoryAndDuplicateIfMatched,
  // {doc.doc = 'For the set of fields with this control at least one of the fields must be present on the input.'} AtLeastOneMandatoryInGroup,
  // {doc.doc = 'Optional field that may or may not produce a match.'} Optional
}

Class {doc.doc = 'Defines how to resolve a single incoming record to match a single record in the master store, handling cases when the primary key is not provided in the input and multiple queries to prevent the creation of duplicates.'}
meta::pure::mastery::metamodel::resolution::IdentityResolution
{
  {doc.doc = 'The master record class that this identity resolution applies to.'} modelClass : Class<Any>[1];
  {doc.doc = 'The set of queries used to identify a single record in the master store. Not required if the Master record has a single equality.Key field defined that is not generated.'} queries : meta::pure::mastery::metamodel::resolution::ResolutionQuery[0..*];
}

Class {doc.doc = 'Defines queries used for identity resolution to identify a master record instance to update and prevent duplicates from being created.'}
meta::pure::mastery::metamodel::resolution::ResolutionQuery
{
  //{doc.doc='Expressions that refer to attributes used to generate queries that are executed on the master store.'}                              resolutionQueries : meta::pure::metamodel::function::FunctionDefinition<Any>[1..*];
  {doc.doc='Expressions that refer to attributes used to generate queries that are executed on the master store.'}                              resolutionQueries : meta::pure::metamodel::function::LambdaFunction<Any>[1..*];
  {doc.doc='The control type used to define how to validate the queries generated from the input and validate the results of query execution.'} keyType : meta::pure::mastery::metamodel::resolution::ResolutionKeyType[1];
  {doc.doc='The query precedence applied when there are more than 1 ResoultionQuery definitions on an IdentityResolution.'}                     precedence : Integer[1];
}

//TODO gallch - doc.doc
Class meta::pure::mastery::metamodel::CollectionEquality 
{
  collectionPath: meta::pure::metamodel::path::PropertyPathElement[1];
  // collectionModel: Class<Any>[1]; - Derive from PatheElement and compiler will check the 2 ANYs are the same, add to doc.
  equalityFunctions: meta::pure::metamodel::function::LambdaFunction<{Any[1],Any[1]->Boolean[1]}>[1..*]; //TODO - discuss with Aziem switching to FunctionDefinition
}

Class meta::pure::mastery::metamodel::RecordSource
{
  id: String[1];
  partitions: meta::pure::mastery::metamodel::RecordSourcePartition[1..*];
  liveStatus: String[1]; //TODO Enum
  description: String[1];
  parseService: meta::legend::service::metamodel::Service[0..1]; 
  transformService: meta::legend::service::metamodel::Service[0..1]; 
  extractTransformedService: meta::legend::service::metamodel::Service[0..1]; 
  sequentialData: Boolean[0..1];
  stagedLoad: Boolean[0..1]; 
  dataProvider: String[1]; //TODO Enum and definition of provider classes
  createPermitted: Boolean[0..1];
  createBlockException: Boolean[0..1];
  certificationTestIds: String[1..*]; //TODO add test specification?
}

Class meta::pure::mastery::metamodel::RecordSourcePartition
{
  id: String[1];
  sourceDependencies: String[*]; //TODO Source/Partition pair as a class?
  dataClassification: String[*]; //
  swingCheck_TO_FILE: String[*];
  runtimePartameters: String[*];
}

Class meta::pure::mastery::metamodel::todo::Schedule_TBC
{
    effectiveDateRollWindow: String[0..1];
}

Class meta::pure::mastery::metamodel::todo::SLO_TBC_NEGOTIATOR
{
}

Class meta::pure::mastery::metamodel::todo::DataQuality_TBC_NEGOTIATOR
{
}

Class meta::pure::mastery::metamodel::todo::WriteConfiguration_TBC
{
}

Class meta::pure::mastery::metamodel::todo::DataStore_Space_Set_TBC
{
  name: String[1];
  description: String[1];
  applicstionId: String[0..1];
  sensitivityLabels: String[1..*];
  schemaName: String[1];
  liveStatus: String[1]; //Was inDemis: Boolean[0..1]
}